# RIBs

[источник](https://habr.com/ru/companies/sports_ru/articles/424305/)

**RIBs** — кроссплатформенный архитектурный фреймворк от Uber. Он был разработан для больших мобильных приложений с большим количеством вложенных состояний.

##### При разработке этой структуры инженеры Uber придерживались следующих принципов:

- **Поддержка сотрудничества между людьми, разрабатывающими на разных платформах**
- **Минимизация глобальных состояний и решений**
- **Тестируемость и изоляция**
- **Инструменты для продуктивной разработки**: Архитектура RIBs поставляется с инструментами IDE для создания кода, статического анализа и интеграции во время выполнения, что повышает производительность разработчиков в больших и малых командах.
- **Принцип открытости-закрытости**
- **Структурирование вокруг бизнес-логики**
- **Точные контракты**: требования должны быть объявлены с помощью контрактов, которые проверяются во время компиляции. Класс не должен компилироваться, если его собственные зависимости, а также гостевые зависимости не удовлетворены.

## Составляющие элементы RIBs

![картинкааа](images/ribs_archit.png)

### Interactor

Interactor содержит бизнес-логику. В этом классе происходит подписка на Rx уведомления, принимаются решения об изменении состояния, хранении данных и прикреплении дочерних RIB.

Все операции, выполняемые в Interactor'е, должны быть ограничены его жизненным циклом. В Uber создали инструментарий для обеспечения того, чтобы бизнес-логика выполнялась только при активном взаимодействии. Это предотвращает дезактивацию Interactor'ов, но Rx подписки по-прежнему срабатывают и вызывают нежелательные обновления бизнес-логики или состояния пользовательского интерфейса.

### Router

Router отслеживает события от Interactor'а и преобразует эти события в прикрепление и открепление дочерних RIB. Router существует по трем простым причинам:

- **Router существует как пассивный объект**, что упрощает тестирование сложной логики Interactor'а без необходимости создавать заглушки для дочерних Interactor'ов или каким-то другим способом заботиться об их существовании.
- **Router'ы создают дополнительный уровень абстракции** между родительским и дочерними Interactor'ами. Это делает синхронную связь между Interactor'ами немного сложнее и стимулирует использование Rx связи вместо прямой связи между RIB.
- **Router'ы содержат простую и повторяющуюся логику** маршрутизации, которая в противном случае была бы реализована в Interactor'ах. Перенос этого шаблонного кода в Router'ы помогает Interactor'ам быть небольшими и более сосредоточенными на основной бизнес-логике RIB.

### Builder

Builder нужен для того, чтобы создать экземпляры для всех классов, входящих в RIB, а также создать экземпляры Builder'ов для дочерних RIB.

Выделение логики создания классов в Builder добавляет поддержку возможности создания заглушек в iOS и делает остальную часть кода RIB нечувствительной к деталями реализации DI. Builder является единственной частью RIB, которая должна быть осведомлена о системе DI, используемой в проекте. Внедряя другой Builder, можно повторно использовать остальную часть кода RIB в проекте с использованием другого механизма DI.

### Presenter

Presenter это класс без состояния, который транслирует бизнес-модель в модель представления и наоборот. Он может использоваться для облегчения тестирования преобразований модели представления. Однако часто этот перевод настолько тривиален, что он не оправдывает создание отдельного класса Presenter. Если Presenter не сделан, то трансляция моделей представления становится обязанностью View (Controller) или Interactor'а.

### View(Controller)

View создает и обновляет пользовательский интерфейс. Он включает в себя создание и расположение компонентов интерфейса, обработку взаимодействия с пользователем, заполнение компонентов пользовательского интерфейса данными и анимацию. View предназначена для того, чтобы быть настолько «тупой»(пассивной), насколько это возможно. Они просто отображают информацию. В общем и целом, они не содержат никакого кода, для которого должны быть написаны unit тесты.

### Component

Component используется для управления зависимостями RIB. Он помогает Builder'у создавать экземпляры других классов, из которых состоит RIB. Component обеспечивает доступ к внешним зависимостям, необходимым для создания RIB, а также к собственным зависимостям, созданными самим RIB, и контролируют доступ к ним из других RIB. Component родительского RIB обычно внедряется в дочерний RIB-Builder, чтобы предоставить дочернему RIB доступ к зависимостям родительского RIB.