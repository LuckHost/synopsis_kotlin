# Basic types 

Всего их 3 штуки:
- Unit
- `Nothing`
- Any

## `Unit`

`Unit` эквивалентен `void` в Java. В этом выражении возвращаемый тип можно не указывать, если функция ничего не возвращает. По умолчанию там будет `Unit`:

```kotlin
fun knockKnock(){
 println("Who’s there?")
}
```

В Kotlin есть два способа объявить функцию: в теле метода (в фигурных скобках) или как выражение (через знак равенства). Можно переписать нашу функцию так, а заодно указать возвращаемое значение:

```kotlin
fun knockKnock(): Unit = println("Who’s there?")
```

В стандартной библиотеке Kotlin `Unit` определён как объект, наследуемый от `Any` и содержащий единственный метод, переопределяющий `toString()`:

```kotlin
public object Unit {
 override fun toString() = "Kotlin.Unit"
}
```

Обратите внимание на ключевое слово `object`. Это значит, что `Unit` является синглтоном. `Unit` ничего не возвращает, а метод `toString` всегда будет возвращать `"kotlin.Unit"`. При компиляции в java-код `Unit` всегда будет превращаться в `void`.

## `Nothing`

С `Nothing` всë гораздо интереснее. `Nothing` — класс, который является наследником любого класса в Kotlin, даже класса с модификатором `final`. При этом `Nothing` нельзя создать — у него приватный конструктор. В коде он объявлен так:

`public class Nothing private constructor()`

Несмотря на всë это, класс `Nothing` довольно полезен. Так как невозможно передать или вернуть тип `Nothing`, он описывает результат «функции, которая никогда ничего не вернёт». Примером может быть функция, которая выбрасывает exception или в которой запущен бесконечный цикл: в любом из этих случаев она никогда не вернёт значения. В приложениях — независимо от того, какой тип данных возвращает функция, — она может никогда не вернуть данные, потому что произошла ошибка или вычисления затянулись на неопределённый срок. В этом случае имеет смысл использовать `Nothing`.

Посмотрим, где это используется в Kotlin. Вот пример: функция `TODO()`, которая часто служит заглушкой в автоматически генерируемых методах.

`public inline fun TODO(): Nothing = throw NotImplementedError()`

Вы можете наблюдать такую картину при автогенерации кода:

```kotlin
override fun getData(word: String): List<Data> {
 TODO("not implemented")
}
```

И хотя возвращаемое значение тут `List<Data>`, мы возвращаем `Nothing`. Именно потому что `Nothing` наследуется от всех классов:

`fun doSomething(): Something = TODO()`

Код прекрасно скомпилируется, потому что `Nothing` наследуется от `Something`. Но приложение сразу же упадёт с `NotImplementedError`, если вы вызовете метод `doSomething`.

Интересно, что в Java нельзя написать что-то подобное: код просто не скомпилируется, потому что `Void` не наследуется от `String`

Ещё один пример может касаться выполнения, например, запроса данных из БД или удалённого сервера. Если произошла ошибка, можно возвращать null вместо данных. И это абсолютно нормально, данных-то нет

А если хочется немного больше информации, чем просто null? Например, узнать тип ошибки. Вот тут `Nothing` приходит на помощь:

```kotlin
val data = getData() { err ->
 when (err) {
 is InvalidStatement -> throw Exception(err.parseError)
 is NoSuchData -> ...
 }
 return Data() //успешный сценарий
}
```

Закрепим:

```kotlin
//Скомпилируются нормально
fun funOne(): Unit { while (true) {} }
fun funTwo(): Nothing { while (true) {} }
//Ок
fun funThree(): Unit { println("hi") }
//Не ок
fun funFour(): Nothing { println("hi") }
```

## `Any`

Класс `Any` находится на вершине иерархии — все классы в Kotlin являются наследниками `Any`. `Any` — это аналог `Object` в Java, но с меньшим количеством методов:

```kotlin
public open class Any {
 public open operator fun equals(other: Any?): Boolean
 public open fun hashCode(): Int
 public open fun toString(): String
}
```

В `java.lang.Object` одиннадцать методов, и пять из них касаются многопоточности. Несмотря на меньшее количество методов, при компиляции в Java-код у любого класса появятся недостающие — тут можно быть спокойными.