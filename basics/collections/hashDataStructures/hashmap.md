# HashMap

Kotlin `HashMap` — это коллекция, которая содержит пары объектов. Реализация интерфейса `MutableMap` на основе [hashSet](HashSet.md) Kotlin. Она хранит данные в виде пары ключ-значение. Ключи карты уникальны, и карта содержит только одно значение для каждого ключа. Она представлена ​​как `HashMap<key, value>` или `HashMap<K, V>` . Реализация `HashMap` на основе [hashSet](HashSet.md) не гарантирует порядок указанных данных ключа, значения и записей коллекций.

## Мотивация использовать хеш-таблицы

Для наглядности рассмотрим стандартные контейнеры и асимптотику их наиболее часто используемых методов.

Контейнер \ операция | insert | remove | find
-|-|-|-
Array | O(N) | O(N) | O(N)
List | O(1) | O(1) | O(N)
Sorted array | O(N) | O(N) | O(logN)
Бинарное дерево поиска | O(logN) | O(logN) | O(logN)
Хеш-таблица | O(1) | O(1) | O(1)

**Главный минус** - Хеш-таблицы тяжеловесные, и, хоть они и быстро отвечают на вопросы основных операций, пользоваться ими все время очень затратно.


## Проблема коллизии

Проблема, когда хеш-функция выдает одинаковое натуральное число для разных элементов.

Существует несколько решений данной проблемы: метод цепочек и метод двойного хеширования.

### Решения проблемы коллизии методом двойного хеширования

Мы будем использовать две хеш-функции, возвращающие взаимопростые натуральные числа.

Одна хеш-функция (при входе g) будет возвращать натуральное число s, которое будет для нас начальным. То есть первое, что мы сделаем, попробуем поставить элемент g на позицию s в нашем массиве. Но что, если это место уже занято? Именно здесь нам пригодится вторая хеш-функция, которая будет возвращать t — шаг, с которым мы будем в дальнейшем искать место, куда бы поставить элемент g.

Мы будем рассматривать сначала элемент s, потом s + t, затем s + 2*t и т.д. Естественно, чтобы не выйти за границы массива, мы обязаны смотреть на номер элемента по модулю (остатку от деления на размер массива).