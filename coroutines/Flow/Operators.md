# Операторы Flow

[источник](https://www.youtube.com/watch?v=O0_5gc24KUo&list=PL0SwNXKJbuNmsKQW9mtTSxNn00oJlYOLA&index=9)

Flow имеет несколько видов операторов
- **стандартные** операторы
- **промежуточные** (модификация потока)
- **терминальные** (запуск данных из flow)

Все эти операторы написаны extention-функциями, что позволяет и нам писать свои

Структура каждого из них довльно проста

```kotlin
fun <T,R> Flow<T>.map(
    transform: suspend (value: T) -> R
): Flow<R> = flow { // Указываем, что возвращаем Flow
    collect { value -> // Собираем данные старого Flow
        val newValue = transform(value) // Производим манипуляции
        emit(newValue) // Эмитим новое значение
    }
}
```

Составить свой оператор по такому же принципу вовсе не сложно 


### Терминальные

Все терминальные операторы - suspend функции, которые должны быть зпущены внутри какого-то scope

Применяются к входному потоку и запускают выполнение всех операций в рамках него

#### Collect

Самый простой оператор, который собирает Flow

Можно использовать в оператором `onEach`, чтобы обрабатывать все поступившие данные

```kotlin
scope.launch {
    flow<String> {}
    ...
        .onEach { ... }
        .collect()
}
```

### Безопасность

Некторые операторы, по типу `toList`, ожидают завершения Flow, что не всегда гарантированно. Из-за чего корутина может быть приостановлена навсегда этого надо избегать

### Кеширование

Flow выполняется тоже последовательно. После эмита новых данных он ожидает все collect, только после чего он может эмитить новые данные

Для избежания проблем, когда коллекторы тормозят поток существует кеширование

```kotlin
flow.buffer(
  capacity = Channel.BUFFERED,
  onBufferOverflow = BufferOverflow.SUSPEND
)
```

Сначала собирает все значения из Flow, а потом передает их коллекторам, когда они будут готовы их обработать 

