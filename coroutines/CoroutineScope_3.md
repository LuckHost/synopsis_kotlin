# runBlocking

блокирует основной поток и там запускает нужные корутины 

# Structured Concurrency

принципы:

- Отмена Scope
scope может отменить выполнение всех дочерних корутин, если есть ошибка или отмена

- Scope знает про все корутины
по принципу ролдитель - ребенок

- Я буду тебя ждать
scope автоматически ожидает выполнения всех корутин, но не обязательно завершает вместе с ним

# отличие Scope от Context

Scope - просто обертка, он собирает все воедино 
Context - набор парметров для корутин 

# GlobalScope
отменить невозможно, работает до окончания, ломает принципы, описанные выше, использовать с осторожностью


## Создание Scope

```
CoroutineScope(Job() + Dispatchers.Deafault)

// or

coroutineScope {
  // параллельные операции
  launch(Dispatchers.IO) {
    //todo
  }
  launch(Dispatchers.IO) {
    //todo
  }
}

```

### Создание дочерних Scope

- креш проьрасывается наврех
- родительский останаливает дочерние
- coroutineScope ждет всех

параметры берутся от родителей, Job создается новый 

### SupervisorScope

использует supervisorJob

# Отделение от UI

родительские Scope не живут дольше родителей, если приложение закрыто, а сообщение надо отправить на сервер, лучше эти scope отделять

# withContext

помогает сменить context